<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Hackathon Orchestrator Dashboard</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet" />
  <style>
    body { font-family: 'Inter', sans-serif; }
    .kpi-card { background-color: #1F2937; }
    .log-panel { background-color: #111827; }
    .status-dot { width: 8px; height: 8px; border-radius: 50%; }
    .status-sourced { background-color: #3B82F6; }
    .status-contacted { background-color: #F59E0B; }
    .status-accepted { background-color: #10B981; }
    .status-scheduled { background-color: #8B5CF6; }
    .status-declined { background-color: #EF4444; }
  </style>
</head>
<body class="bg-gray-900 text-gray-200 antialiased">
  <div class="container mx-auto p-4 md:p-8">
    <div class="flex items-center justify-between mb-6">
      <h1 class="text-2xl font-bold text-white">Hackathon Orchestrator Dashboard</h1>
      <div class="flex items-center gap-3">
        <a id="bot-link" href="bot.html" class="text-sm bg-blue-600 hover:bg-blue-700 text-white px-3 py-1 rounded">ü§ñ Discord Bot</a>
      </div>
    </div>


    <!-- Main Content -->
    <main>


      <!-- Speaker Finder Section -->
      <div class="bg-gray-800 p-6 rounded-lg shadow-lg mb-8">
        <h2 class="text-xl font-semibold text-white mb-4">üé§ Speaker & Jury Finder</h2>
        <p class="text-gray-400 mb-4">Find speakers and jury members for your hackathon topic and get a Google Sheets link instantly.</p>
        <div class="flex flex-col sm:flex-row gap-4">
          <input type="text" id="speaker-topic" class="flex-grow bg-gray-700 border border-gray-600 text-white rounded-md p-3 focus:ring-2 focus:ring-blue-500 focus:outline-none" placeholder="e.g., 'AI in FinTech', 'Cybersecurity', 'Blockchain'" />
          <input type="number" id="speaker-count" class="w-24 bg-gray-700 border border-gray-600 text-white rounded-md p-3 focus:ring-2 focus:ring-blue-500 focus:outline-none" placeholder="20" min="1" max="50" value="20" />
          <button id="find-speakers-btn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-md transition duration-300 shadow-md">üîç Find Speakers</button>
        </div>
        <div id="speaker-result" class="mt-4 hidden">
          <div class="bg-green-900 border border-green-700 rounded-lg p-4">
            <h3 class="text-lg font-semibold text-green-200 mb-2">‚úÖ Speakers Found!</h3>
            <p id="speaker-message" class="text-green-300 mb-3"></p>
            <a id="spreadsheet-link" href="#" target="_blank" class="inline-block bg-green-700 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-md transition duration-300">üìä Open Google Sheets</a>
          </div>
        </div>
        <div id="speaker-error" class="mt-4 hidden">
          <div class="bg-red-900 border border-red-700 rounded-lg p-4">
            <h3 class="text-lg font-semibold text-red-200 mb-2">‚ùå Error</h3>
            <p id="speaker-error-message" class="text-red-300"></p>
          </div>
        </div>
      </div>

      <!-- Dashboard & Logs Grid -->
      <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
        <!-- Left Column: Dashboard -->
        <div class="lg:col-span-1 flex flex-col gap-8">
          <!-- KPI Cards -->
          <div>
            <h2 class="text-xl font-semibold text-white mb-4">Live Metrics</h2>
            <div class="grid grid-cols-3 gap-4">
              <div id="kpi-sourced" class="kpi-card p-4 rounded-lg text-center">
                <p class="text-3xl font-bold">0</p>
                <p class="text-sm text-gray-400">Sourced</p>
              </div>
              <div id="kpi-contacted" class="kpi-card p-4 rounded-lg text-center">
                <p class="text-3xl font-bold">0</p>
                <p class="text-sm text-gray-400">Contacted</p>
              </div>
              <div id="kpi-accepted" class="kpi-card p-4 rounded-lg text-center">
                <p class="text-3xl font-bold">0</p>
                <p class="text-sm text-gray-400">Accepted</p>
              </div>
            </div>
          </div>
          <!-- Candidate List -->
          <div>
            <h2 class="text-xl font-semibold text-white mb-4">Candidate Pipeline</h2>
            
            <!-- Bulk Actions for Candidates -->
            <div id="bulk-actions" class="mb-4 p-3 bg-gray-700 rounded-lg hidden">
              <div class="flex items-center justify-between mb-2">
                <span class="text-sm text-gray-300">
                  <span id="selected-count">0</span> candidates selected
                </span>
                <div class="flex gap-2">
                  <button id="select-all-btn" class="text-xs bg-gray-600 hover:bg-gray-500 text-white px-2 py-1 rounded">
                    Select All
                  </button>
                  <button id="select-none-btn" class="text-xs bg-gray-600 hover:bg-gray-500 text-white px-2 py-1 rounded">
                    Select None
                  </button>
                </div>
              </div>
              <div class="flex gap-2">
                <button id="send-bulk-emails-btn" class="bg-blue-600 hover:bg-blue-700 text-white text-sm px-4 py-2 rounded transition">
                  üìß Send Emails to Selected
                </button>
                <button id="check-bulk-responses-btn" class="bg-yellow-600 hover:bg-yellow-700 text-white text-sm px-4 py-2 rounded transition">
                  üîç Check All Responses
                </button>
              </div>
            </div>
            
            <div id="candidate-list" class="space-y-3">
              <!-- JS will populate this -->
              <p class="text-gray-500 text-center py-4">Launch an agent to see candidates here.</p>
            </div>
          </div>
        </div>

        <!-- Right Column: Live Log -->
        <div class="lg:col-span-2">
          <h2 class="text-xl font-semibold text-white mb-4">Live Execution Log</h2>
          <div id="log-panel" class="log-panel p-4 rounded-lg h-96 overflow-y-auto font-mono text-sm">
            <p class="text-gray-500">Awaiting agent launch...</p>
          </div>
        </div>
      </div>

      <!-- Discord Bot moved to dedicated page -->
      <section class="mt-12 bg-gray-800 p-6 rounded-lg shadow-lg">
        <h2 class="text-2xl font-semibold text-white mb-4">ü§ñ Discord Bot</h2>
        <p class="text-gray-400 mb-6">The Discord bot configuration has moved to its own page.</p>
        <a id="open-bot-page" class="inline-block bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-md transition duration-300 shadow-md" href="#">Open Discord Bot Page ‚Üí</a>
      </section>

      <!-- Business Plan & Goals -->
      <section class="mt-12 bg-gray-800 p-6 rounded-lg shadow-lg">
        <h2 class="text-2xl font-semibold text-white mb-4">Business Plan & Goals</h2>
        <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
          <div>
            <h3 class="text-lg font-semibold text-white">Problem</h3>
            <p class="text-gray-400 mt-2">Event teams spend weeks sourcing, emailing, and scheduling high-quality speakers and jurors. Manual workflows lead to low hit rates and missed deadlines.</p>
          </div>
          <div>
            <h3 class="text-lg font-semibold text-white">Solution</h3>
            <p class="text-gray-400 mt-2">An AI-driven orchestrator that identifies experts, personalizes outreach, and books meetings automatically‚Äîintegrated with Gmail and Google Calendar.</p>
          </div>
          <div>
            <h3 class="text-lg font-semibold text-white">Outcomes</h3>
            <ul class="text-gray-400 mt-2 list-disc list-inside space-y-1">
              <li>Reduce sourcing time by 80%+</li>
              <li>Increase response rates via personalized outreach</li>
              <li>Hands-free scheduling with conflict-aware calendars</li>
            </ul>
          </div>
        </div>
        <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mt-6">
          <div>
            <h3 class="text-lg font-semibold text-white">Target Users</h3>
            <ul class="text-gray-400 mt-2 list-disc list-inside space-y-1">
              <li>Hackathon organizers</li>
              <li>Conference teams</li>
              <li>University clubs</li>
            </ul>
          </div>
          <div>
            <h3 class="text-lg font-semibold text-white">Pricing</h3>
            <p class="text-gray-400 mt-2">Tiered SaaS: Starter (per-event), Pro (monthly), Enterprise (SSO, audit logs, SLAs).</p>
          </div>
          <div>
            <h3 class="text-lg font-semibold text-white">Roadmap</h3>
            <ul class="text-gray-400 mt-2 list-disc list-inside space-y-1">
              <li>CRM integrations (HubSpot, Salesforce)</li>
              <li>Multi-channel outreach (LinkedIn, email)</li>
              <li>Auto follow-ups and A/B testing</li>
            </ul>
          </div>
        </div>
      </section>
    </main>
  </div>

  <script>
    // --- DOM Elements ---
    const logPanel = document.getElementById('log-panel');
    const candidateList = document.getElementById('candidate-list');
    const kpiSourced = document.getElementById('kpi-sourced').querySelector('p:first-child');
    const kpiContacted = document.getElementById('kpi-contacted').querySelector('p:first-child');
    const kpiAccepted = document.getElementById('kpi-accepted').querySelector('p:first-child');

    // Speaker Finder Elements
    const speakerTopicInput = document.getElementById('speaker-topic');
    const speakerCountInput = document.getElementById('speaker-count');
    const findSpeakersBtn = document.getElementById('find-speakers-btn');
    const speakerResult = document.getElementById('speaker-result');
    const speakerError = document.getElementById('speaker-error');
    const speakerMessage = document.getElementById('speaker-message');
    const spreadsheetLink = document.getElementById('spreadsheet-link');
    const speakerErrorMessage = document.getElementById('speaker-error-message');

    // --- Config ---
    const urlParams = new URLSearchParams(window.location.search);
    const apiPort = urlParams.get('api') || '8001';
    const apiBase = `http://127.0.0.1:${apiPort}`;
    // Update nav link to preserve api param
    const botLinkEl = document.getElementById('bot-link');
    if (botLinkEl) botLinkEl.href = `bot.html?api=${apiPort}`;
    
    // Debug: Log the API base URL
    console.log('API Base URL:', apiBase);
    console.log('Frontend URL:', window.location.href);

    // --- State & Mock Data ---
    let candidates = [];
    let logEventSource = null;

    // --- Core Functions ---
    function addLog(message, type = 'info') {
      const colors = { info: 'text-gray-400', success: 'text-green-400', agent: 'text-blue-400' };
      const logEntry = document.createElement('p');
      logEntry.innerHTML = `<span class="mr-2">${new Date().toLocaleTimeString()}</span> <span class="${colors[type]}">${message}</span>`;
      logPanel.appendChild(logEntry);
      logPanel.scrollTop = logPanel.scrollHeight; // Auto-scroll
    }

    function updateDashboard() {
      kpiSourced.textContent = candidates.length;
      kpiContacted.textContent = candidates.filter(c => c.status === 'Contacted' || c.status === 'Accepted').length;
      kpiAccepted.textContent = candidates.filter(c => c.status === 'Accepted').length;

      candidateList.innerHTML = '';
      if (candidates.length === 0) {
        candidateList.innerHTML = '<p class="text-gray-500 text-center py-4">Launch an agent to see candidates here.</p>';
        return;
      }

      candidates.forEach((c, index) => {
        const statusClasses = { 
          Sourced: 'status-sourced', 
          Contacted: 'status-contacted', 
          Accepted: 'status-accepted',
          Scheduled: 'status-scheduled',
          Declined: 'status-declined'
        };
        const candidateEl = document.createElement('div');
        candidateEl.className = 'kpi-card p-3 rounded-md';
        candidateEl.innerHTML = `
          <div class="flex items-center justify-between mb-2">
            <div class="flex items-center gap-3">
              <input type="checkbox" 
                     id="candidate-${index}" 
                     class="candidate-checkbox w-4 h-4 text-blue-600 bg-gray-700 border-gray-600 rounded focus:ring-blue-500"
                     data-index="${index}"
                     onchange="updateSelectedCount()">
              <div>
                <p class="font-semibold text-white">${c.name}</p>
                <p class="text-xs text-gray-400">${c.expertise}</p>
                <p class="text-xs text-gray-500">${c.email}</p>
              </div>
            </div>
            <div class="flex items-center gap-2">
              <span class="text-xs font-medium">${c.status}</span>
              <div class="status-dot ${statusClasses[c.status]}"></div>
            </div>
          </div>
          
          <!-- Individual Actions -->
          <div class="flex gap-2 mt-2">
            ${c.status === 'Contacted' ? `
              <button onclick="checkCandidateResponse(${index})" 
                      class="bg-yellow-600 hover:bg-yellow-700 text-white text-xs px-3 py-1 rounded transition duration-200">
                üîç Check Response
              </button>
            ` : ''}
            ${c.status === 'Accepted' && c.availableTimes ? `
              <button onclick="showTimeSelection(${index})" 
                      class="bg-green-600 hover:bg-green-700 text-white text-xs px-3 py-1 rounded transition duration-200">
                üìÖ Schedule Meeting
              </button>
            ` : ''}
          </div>
          
          <!-- Status Information -->
          ${c.availableTimes ? `
            <div class="mt-2 text-xs text-green-300">
              Available: ${c.availableTimes.join(', ')}
            </div>
          ` : ''}
          ${c.responseMessage ? `
            <div class="mt-2 p-2 bg-gray-700 rounded text-xs">
              <strong class="text-green-300">Response:</strong> ${c.responseMessage}
            </div>
          ` : ''}
          ${c.scheduledTime ? `
            <div class="mt-2 p-2 bg-purple-900 rounded text-xs">
              <strong class="text-purple-300">Scheduled:</strong> ${c.scheduledTime}
              ${c.meetingLink ? `<br><a href="${c.meetingLink}" target="_blank" class="text-blue-400 hover:text-blue-300">üìÖ Join Meeting</a>` : ''}
            </div>
          ` : ''}
        `;
        candidateList.appendChild(candidateEl);
      });
      
      // Show bulk actions if there are candidates
      const bulkActions = document.getElementById('bulk-actions');
      if (candidates.length > 0) {
        bulkActions.classList.remove('hidden');
      } else {
        bulkActions.classList.add('hidden');
      }
      
      updateSelectedCount();
    }



    // --- Speaker Finder Functions ---
    async function findSpeakers() {
      const topic = speakerTopicInput.value.trim();
      const maxResults = parseInt(speakerCountInput.value) || 20;
      
      if (!topic) {
        alert('Please enter a topic to search for speakers.');
        return;
      }
      
      // Reset UI
      speakerResult.classList.add('hidden');
      speakerError.classList.add('hidden');
      findSpeakersBtn.disabled = true;
      findSpeakersBtn.textContent = 'üîç Searching...';
      
      console.log('Calling API:', `${apiBase}/speakers/find`);
      console.log('Request payload:', { topic, max_results: maxResults });
      
      try {
        const response = await fetch(`${apiBase}/speakers/find`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            topic: topic,
            max_results: maxResults
          })
        });
        
        console.log('Response status:', response.status);
        console.log('Response headers:', response.headers);
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const data = await response.json();
        
        if (data.ok) {
          speakerMessage.textContent = data.message;
          spreadsheetLink.href = data.spreadsheet_url;
          speakerResult.classList.remove('hidden');
          addLog(`Found ${maxResults} speakers for "${topic}" and created Google Sheets`, 'success');
          
          // Also populate the candidate pipeline with found speakers
          if (data.speakers && data.speakers.length > 0) {
            candidates = data.speakers.map(speaker => ({
              name: speaker.name || 'Unknown',
              email: speaker.email || '',
              expertise: speaker.expertise || topic,
              status: 'Sourced'
            }));
            
            addLog(`Loaded ${candidates.length} candidates into pipeline`, 'success');
            updateDashboard();
          } else {
            // Create mock candidates for demo if no speakers data returned
            const mockCandidates = [];
            for (let i = 1; i <= Math.min(maxResults, 5); i++) {
              mockCandidates.push({
                name: `${topic} Expert ${i}`,
                email: `expert${i}@${topic.toLowerCase().replace(/\s+/g, '')}.com`,
                expertise: topic,
                status: 'Sourced'
              });
            }
            candidates = mockCandidates;
            addLog(`Created ${candidates.length} demo candidates for "${topic}"`, 'success');
            updateDashboard();
          }
        } else {
          throw new Error(data.detail || 'Failed to find speakers');
        }
      } catch (error) {
        console.error('Error in findSpeakers:', error);
        speakerErrorMessage.textContent = error.message;
        speakerError.classList.remove('hidden');
        addLog(`Error finding speakers: ${error.message}`, 'info');
      } finally {
        findSpeakersBtn.disabled = false;
        findSpeakersBtn.textContent = 'üîç Find Speakers';
      }
    }
    

    

    


    // --- Bulk Selection Functions ---
    function updateSelectedCount() {
      const checkboxes = document.querySelectorAll('.candidate-checkbox:checked');
      const count = checkboxes.length;
      const countElement = document.getElementById('selected-count');
      const sendBulkBtn = document.getElementById('send-bulk-emails-btn');
      const checkBulkBtn = document.getElementById('check-bulk-responses-btn');
      
      if (countElement) countElement.textContent = count;
      
      // Enable/disable bulk action buttons based on selection
      if (sendBulkBtn) sendBulkBtn.disabled = count === 0;
      if (checkBulkBtn) checkBulkBtn.disabled = count === 0;
    }

    function selectAllCandidates() {
      const checkboxes = document.querySelectorAll('.candidate-checkbox');
      checkboxes.forEach(checkbox => {
        checkbox.checked = true;
      });
      updateSelectedCount();
    }

    function selectNoneCandidates() {
      const checkboxes = document.querySelectorAll('.candidate-checkbox');
      checkboxes.forEach(checkbox => {
        checkbox.checked = false;
      });
      updateSelectedCount();
    }

    function getSelectedCandidates() {
      const checkboxes = document.querySelectorAll('.candidate-checkbox:checked');
      const selectedCandidates = [];
      
      checkboxes.forEach(checkbox => {
        const index = parseInt(checkbox.dataset.index);
        if (candidates[index]) {
          selectedCandidates.push({
            index: index,
            candidate: candidates[index]
          });
        }
      });
      
      return selectedCandidates;
    }

    async function sendBulkEmails() {
      const selected = getSelectedCandidates();
      const sourcedCandidates = selected.filter(item => item.candidate.status === 'Sourced');
      
      if (sourcedCandidates.length === 0) {
        alert('No sourced candidates selected. Please select candidates that haven\'t been contacted yet.');
        return;
      }

      if (!confirm(`Send emails to ${sourcedCandidates.length} selected candidates?`)) {
        return;
      }

      const sendBtn = document.getElementById('send-bulk-emails-btn');
      const originalText = sendBtn.textContent;
      sendBtn.disabled = true;
      sendBtn.textContent = 'üìß Sending...';

      let successCount = 0;
      let errorCount = 0;

      addLog(`Starting bulk email send to ${sourcedCandidates.length} candidates...`, 'info');

      for (const item of sourcedCandidates) {
        try {
          addLog(`Sending email to ${item.candidate.name}...`, 'info');
          
          const response = await fetch(`${apiBase}/outreach/send-individual`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              candidate: item.candidate,
              subject: `Invitation to speak at our hackathon${speakerTopicInput.value ? ' - ' + speakerTopicInput.value : ''}`,
              bodyTemplate: `Hi {name},

We're organizing an exciting hackathon and would love to invite you as a speaker/jury member.

Your expertise in ${item.candidate.expertise} would be invaluable to our participants. The event is designed to foster innovation and learning in this rapidly evolving field.

Would you be interested in participating? If so, could you please share your availability for the next 2-3 weeks?

Looking forward to your response!

Best regards,
Hackathon Team`
            })
          });

          if (response.ok) {
            const data = await response.json();
            candidates[item.index].status = 'Contacted';
            candidates[item.index].refToken = data.refToken;
            successCount++;
            addLog(`‚úÖ Email sent to ${item.candidate.name}`, 'success');
            
            // Auto-check for response after a delay
            setTimeout(() => checkCandidateResponse(item.index), 15000);
          } else {
            throw new Error('Failed to send email');
          }
        } catch (error) {
          errorCount++;
          addLog(`‚ùå Failed to send email to ${item.candidate.name}: ${error.message}`, 'info');
        }
        
        // Small delay between emails
        await new Promise(resolve => setTimeout(resolve, 500));
      }

      addLog(`Bulk email complete: ${successCount} sent, ${errorCount} failed`, successCount > 0 ? 'success' : 'info');
      
      sendBtn.disabled = false;
      sendBtn.textContent = originalText;
      
      updateDashboard();
      updateSelectedCount();
    }

    async function checkBulkResponses() {
      const selected = getSelectedCandidates();
      const contactedCandidates = selected.filter(item => 
        item.candidate.status === 'Contacted' && item.candidate.refToken
      );
      
      if (contactedCandidates.length === 0) {
        alert('No contacted candidates selected. Please select candidates that have been contacted.');
        return;
      }

      const checkBtn = document.getElementById('check-bulk-responses-btn');
      const originalText = checkBtn.textContent;
      checkBtn.disabled = true;
      checkBtn.textContent = 'üîç Checking...';

      addLog(`Checking responses for ${contactedCandidates.length} candidates...`, 'info');

      for (const item of contactedCandidates) {
        await checkCandidateResponse(item.index);
        // Small delay between checks
        await new Promise(resolve => setTimeout(resolve, 1000));
      }

      checkBtn.disabled = false;
      checkBtn.textContent = originalText;
      
      addLog(`Bulk response check complete`, 'info');
    }

    // --- Individual Candidate Functions ---

    async function checkCandidateResponse(candidateIndex) {
      const candidate = candidates[candidateIndex];
      if (!candidate || !candidate.refToken) return;

      try {
        addLog(`Checking for response from ${candidate.name}...`, 'info');
        
        const response = await fetch(`${apiBase}/outreach/check-response`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            refToken: candidate.refToken,
            candidateEmail: candidate.email
          })
        });

        if (response.ok) {
          const data = await response.json();
          if (data.hasResponse) {
            candidate.responseMessage = data.responseText;
            
            if (data.isPositive) {
              candidate.status = 'Accepted';
              candidate.availableTimes = data.availableTimes || [];
              addLog(`‚úÖ ${candidate.name} responded positively! Available times: ${candidate.availableTimes.join(', ')}`, 'success');
            } else {
              candidate.status = 'Declined';
              addLog(`${candidate.name} declined the invitation.`, 'info');
            }
            
            updateDashboard();
          } else {
            addLog(`No response yet from ${candidate.name}`, 'info');
            // Continue monitoring
            setTimeout(() => checkCandidateResponse(candidateIndex), 30000); // Check again in 30 seconds
          }
        }
      } catch (error) {
        addLog(`‚ùå Error checking response from ${candidate.name}: ${error.message}`, 'info');
      }
    }

    function showTimeSelection(candidateIndex) {
      const candidate = candidates[candidateIndex];
      if (!candidate || !candidate.availableTimes) return;

      // Create modal for time selection
      const modal = document.createElement('div');
      modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
      modal.innerHTML = `
        <div class="bg-gray-800 p-6 rounded-lg max-w-md w-full mx-4">
          <h3 class="text-lg font-semibold text-white mb-4">Schedule Meeting with ${candidate.name}</h3>
          <p class="text-gray-400 mb-4">Select a time slot:</p>
          <div class="space-y-2 mb-4">
            ${candidate.availableTimes.map((time, index) => `
              <label class="flex items-center space-x-2 cursor-pointer">
                <input type="radio" name="timeSlot" value="${time}" class="text-blue-600">
                <span class="text-gray-300">${time}</span>
              </label>
            `).join('')}
          </div>
          <div class="flex gap-2 justify-end">
            <button onclick="closeTimeModal()" class="bg-gray-600 hover:bg-gray-700 text-white px-4 py-2 rounded">
              Cancel
            </button>
            <button onclick="scheduleMeeting(${candidateIndex})" class="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded">
              Schedule Meeting
            </button>
          </div>
        </div>
      `;
      
      document.body.appendChild(modal);
      window.currentTimeModal = modal;
    }

    function closeTimeModal() {
      if (window.currentTimeModal) {
        document.body.removeChild(window.currentTimeModal);
        window.currentTimeModal = null;
      }
    }

    async function scheduleMeeting(candidateIndex) {
      const candidate = candidates[candidateIndex];
      const selectedTime = document.querySelector('input[name="timeSlot"]:checked')?.value;
      
      if (!selectedTime) {
        alert('Please select a time slot');
        return;
      }

      try {
        addLog(`Scheduling meeting with ${candidate.name} for ${selectedTime}...`, 'info');
        
        const response = await fetch(`${apiBase}/outreach/schedule-meeting`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            candidate: candidate,
            selectedTime: selectedTime,
            summary: `Hackathon Discussion`,
            description: `Meeting with ${candidate.name} to discuss their participation in our hackathon`,
            duration: 30
          })
        });

        if (response.ok) {
          const data = await response.json();
          candidate.status = 'Scheduled';
          candidate.meetingLink = data.meetingLink;
          candidate.scheduledTime = selectedTime;
          
          updateDashboard();
          addLog(`‚úÖ Meeting scheduled with ${candidate.name} for ${selectedTime}`, 'success');
          closeTimeModal();
          
          if (data.meetingLink) {
            alert(`Meeting scheduled! Join link: ${data.meetingLink}`);
          }
        } else {
          throw new Error('Failed to schedule meeting');
        }
      } catch (error) {
        addLog(`‚ùå Failed to schedule meeting with ${candidate.name}: ${error.message}`, 'info');
      }
    }

    // --- Discord Bot navigation ---

    // Discord bot configuration elements
    const discordResults = document.getElementById('discord-results');
    const discordResultsContent = document.getElementById('discord-results-content');
    const discordEventsLog = document.getElementById('discord-events-log');
    const thresholdSlider = document.getElementById('discord-escalation-threshold');
    const thresholdValue = document.getElementById('threshold-value');

    // Update threshold display
    thresholdSlider.addEventListener('input', (e) => {
      thresholdValue.textContent = e.target.value;
    });

    function showDiscordResult(result, isError = false) {
      discordResults.classList.remove('hidden');
      discordResultsContent.textContent = JSON.stringify(result, null, 2);
      discordResultsContent.className = isError 
        ? 'text-red-400 bg-black p-3 rounded text-sm overflow-x-auto'
        : 'text-green-400 bg-black p-3 rounded text-sm overflow-x-auto';
    }

    function addDiscordEvent(eventData) {
      const timestamp = new Date().toLocaleTimeString();
      const eventDiv = document.createElement('div');
      eventDiv.className = 'mb-2 p-2 border-l-2 border-blue-500 bg-gray-800';
      eventDiv.innerHTML = `
        <div class="text-xs text-gray-400">${timestamp}</div>
        <div class="text-sm text-blue-300">${eventData.type || 'unknown'}</div>
        <div class="text-xs text-gray-300">${JSON.stringify(eventData, null, 2)}</div>
      `;
      
      // Remove "No Discord events yet..." message if it exists
      const placeholder = discordEventsLog.querySelector('p');
      if (placeholder && placeholder.textContent.includes('No Discord events yet')) {
        placeholder.remove();
      }
      
      discordEventsLog.appendChild(eventDiv);
      discordEventsLog.scrollTop = discordEventsLog.scrollHeight;
    }

    function getDiscordConfiguration() {
      return {
        hackathon_id: document.getElementById('discord-hackathon-id').value,
        discord: {
          guild_id: document.getElementById('discord-guild-id').value,
          installation_id: document.getElementById('discord-installation-id').value
        },
        features: {
          faq_autoreply: document.getElementById('feature-faq-autoreply').checked,
          flood_detection: document.getElementById('feature-flood-detection').checked,
          escalation: document.getElementById('feature-escalation').checked,
          scheduled_announcements: document.getElementById('feature-scheduled-announcements').checked,
          thread_autocreate: document.getElementById('feature-thread-autocreate').checked,
          sentiment_detection: document.getElementById('feature-sentiment-detection').checked,
          pin_auto_answers: document.getElementById('feature-pin-auto-answers').checked
        },
        escalation: {
          enabled: document.getElementById('feature-escalation').checked,
          channel_id: document.getElementById('discord-escalation-channel').value,
          escalation_threshold: parseFloat(document.getElementById('discord-escalation-threshold').value),
          notify_roles: []
        },
        faq: {
          source: "platform",
          auto_sync: true,
          sync_interval_minutes: 15
        },
        schedule: {
          source: "platform",
          timezone: "UTC",
          reminder_lead_minutes: [10, 60, 1440]
        },
        embeddings: {
          vector_store: "pgvector",
          similarity_threshold: 0.78
        },
        personality: {
          tone: document.getElementById('discord-personality').value,
          welcome_message: document.getElementById('discord-welcome-message').value || undefined
        },
        logging: {
          send_to_platform_webhook: document.getElementById('feature-webhook-enabled').checked,
          platform_webhook_url: document.getElementById('discord-webhook-url').value
        }
      };
    }

    async function configureDiscordBot() {
      const config = getDiscordConfiguration();
      
      if (!config.hackathon_id || !config.discord.guild_id || !config.discord.installation_id) {
        alert('Please fill in all required fields (Hackathon ID, Discord Server ID, Installation ID)');
        return;
      }

      if (config.features.escalation && !config.escalation.channel_id) {
        alert('Please provide an escalation channel ID when escalation is enabled');
        return;
      }

      if (config.logging.send_to_platform_webhook && !config.logging.platform_webhook_url) {
        alert('Please provide a webhook URL when webhook events are enabled');
        return;
      }

      const btn = document.getElementById('configure-discord-bot-btn');
      const originalText = btn.textContent;
      btn.disabled = true;
      btn.textContent = '‚öôÔ∏è Configuring...';

      try {
        const response = await fetch(`${apiBase}/api/v1/bot/configure`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer demo-token' // In production, use real JWT
          },
          body: JSON.stringify(config)
        });

        const result = await response.json();
        
        if (response.ok) {
          showDiscordResult(result);
          addLog('‚úÖ Discord bot configured successfully', 'success');
          addDiscordEvent({ type: 'bot_configured', config_id: result.config_id });
        } else {
          throw new Error(result.detail || 'Configuration failed');
        }
      } catch (error) {
        showDiscordResult({ error: error.message }, true);
        addLog(`‚ùå Discord bot configuration failed: ${error.message}`, 'info');
      } finally {
        btn.disabled = false;
        btn.textContent = originalText;
      }
    }

    async function testDiscordConfig() {
      const config = getDiscordConfiguration();
      
      const btn = document.getElementById('test-discord-config-btn');
      const originalText = btn.textContent;
      btn.disabled = true;
      btn.textContent = 'üß™ Testing...';

      try {
        // Test configuration by getting current config
        const response = await fetch(`${apiBase}/api/v1/bot/configure?hackathon_id=${config.hackathon_id}`, {
          method: 'GET',
          headers: {
            'Authorization': 'Bearer demo-token'
          }
        });

        if (response.ok) {
          const result = await response.json();
          showDiscordResult({ status: 'Configuration test passed', config: result });
          addLog('‚úÖ Discord bot configuration test passed', 'success');
        } else if (response.status === 404) {
          showDiscordResult({ status: 'No configuration found', message: 'Please configure the bot first' });
          addLog('‚ÑπÔ∏è No Discord bot configuration found for this hackathon', 'info');
        } else {
          throw new Error('Configuration test failed');
        }
      } catch (error) {
        showDiscordResult({ error: error.message }, true);
        addLog(`‚ùå Discord bot test failed: ${error.message}`, 'info');
      } finally {
        btn.disabled = false;
        btn.textContent = originalText;
      }
    }

    async function syncDiscordFAQs() {
      const hackathonId = document.getElementById('discord-hackathon-id').value;
      
      if (!hackathonId) {
        alert('Please provide a Hackathon ID');
        return;
      }

      const btn = document.getElementById('sync-discord-faqs-btn');
      const originalText = btn.textContent;
      btn.disabled = true;
      btn.textContent = 'üîÑ Syncing...';

      try {
        // Get FAQs from platform
        const faqResponse = await fetch(`${apiBase}/hackathon/${hackathonId}/faq`, {
          method: 'POST'
        });

        if (!faqResponse.ok) {
          throw new Error('Failed to fetch FAQs from platform');
        }

        const faqData = await faqResponse.json();
        
        // Sync with Discord bot
        const syncResponse = await fetch(`${apiBase}/discord/faq/sync`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            hackathon_id: hackathonId,
            faqs: faqData.faqs
          })
        });

        const result = await syncResponse.json();
        
        if (syncResponse.ok) {
          showDiscordResult(result);
          addLog(`‚úÖ Synced ${result.synced_count} FAQs with Discord bot`, 'success');
          addDiscordEvent({ type: 'faq_sync', synced_count: result.synced_count });
        } else {
          throw new Error(result.detail || 'FAQ sync failed');
        }
      } catch (error) {
        showDiscordResult({ error: error.message }, true);
        addLog(`‚ùå FAQ sync failed: ${error.message}`, 'info');
      } finally {
        btn.disabled = false;
        btn.textContent = originalText;
      }
    }

    async function checkDiscordHealth() {
      const btn = document.getElementById('discord-health-btn');
      const originalText = btn.textContent;
      btn.disabled = true;
      btn.textContent = '‚ù§Ô∏è Checking...';

      try {
        const response = await fetch(`${apiBase}/discord/health`);
        const result = await response.json();
        
        showDiscordResult(result);
        
        if (result.ok) {
          addLog('‚úÖ Discord bot service is healthy', 'success');
        } else {
          addLog(`‚ö†Ô∏è Discord bot service status: ${result.status}`, 'info');
        }
      } catch (error) {
        showDiscordResult({ error: error.message }, true);
        addLog(`‚ùå Discord health check failed: ${error.message}`, 'info');
      } finally {
        btn.disabled = false;
        btn.textContent = originalText;
      }
    }

    // Listen for Discord events in SSE stream
    function handleDiscordEvents(data) {
      if (data.type === 'discord_event') {
        addDiscordEvent(data.data);
      }
    }

    // Extend existing SSE handler to include Discord events
    const originalConnectToBackend = connectToBackend;
    connectToBackend = function() {
      originalConnectToBackend();
      
      if (logEventSource) {
        logEventSource.addEventListener('discord_event', (event) => {
          try {
            const data = JSON.parse(event.data);
            handleDiscordEvents(data);
          } catch (error) {
            console.error('Error parsing Discord event:', error);
          }
        });
      }
    };

    // --- Event Listeners ---
    
    // Speaker finder handler
    findSpeakersBtn.addEventListener('click', findSpeakers);
    
    // Bulk selection handlers
    document.getElementById('select-all-btn').addEventListener('click', selectAllCandidates);
    document.getElementById('select-none-btn').addEventListener('click', selectNoneCandidates);
    document.getElementById('send-bulk-emails-btn').addEventListener('click', sendBulkEmails);
    document.getElementById('check-bulk-responses-btn').addEventListener('click', checkBulkResponses);

    // Open dedicated bot page button
    const openBotBtn = document.getElementById('open-bot-page');
    if (openBotBtn) {
      openBotBtn.addEventListener('click', (e) => {
        e.preventDefault();
        window.location.href = `bot.html?api=${apiPort}`;
      });
    }

    // Initial state
    updateDashboard();
  </script>
</body>
</html>
